import polars as pl
import datetime
import os

# -----------------------------
# NOte: RDATE issue, store SAS data? not longer require or change format 
#
# TO RUN ON WEEKLY BASIS                            
# ESMR: 2011-1379 / EJS: A2011-8660 / 2014-2484     
# 1ST,9TH,16TH,23RD    
# Depend on FTPEPCU1
# 
#                              
# Step 1. Reporting Date (simulate SAS REPTDATE)
# -----------------------------

batch_date = datetime.date.today() - datetime.timedelta(days=6)
day = batch_date.day
month = batch_date.month
year = batch_date.year

REPTDAY = f"{day:02d}"
REPTMON = f"{month:02d}"
REPTYEAR = str(year)[-2:]
RDATE = f"{batch_date.timetuple().tm_yday:05d}"
REPTDATE = batch_date.strftime('%d%m%Y')


#print(f"batch_date: {batch_date}")
#print(f"RDATE: {RDATE}")
#print(f"REPTDATE: {REPTDATE}")

#------------------------------------
# Step 2. input file : SAP.PBB.EPCU.CTCS.TXT(0)
# Check date
#------------------------------------

# First part: Read and process TXTFILE
# Read first row of text file with fixed width positions

ctcs_path = "/pythonITD/mis_dev/source_data/EPCU_CTCS.TXT"

df_txt = pl.read_csv(
    ctcs_path,
    has_header=False,
    skip_rows=0,
    n_rows=1,
    new_columns=["line"]
)

# Extract fields using string slicing (equivalent to @ position in SAS)
first_line = df_txt["line"][0]
YY = int(first_line[2:6])    # @003 4. (positions 3-6, 0-indexed)
MM = int(first_line[6:8])    # @007 2. (positions 7-8)
DD = int(first_line[8:10])   # @009 2. (positions 9-10)

# Calculate TDATE (MDY(MM,DD,YY)-1)
TDATE = datetime.date(YY, MM, DD) - datetime.timedelta(days=1)

# Create equivalent macro variables
FILEDAY = TDATE.strftime('%d')      # PUT(DAY(TDATE),Z2.)
FILEMON = TDATE.strftime('%m')      # PUT(MONTH(TDATE),Z2.)
FILEYEAR = TDATE.strftime('%y')     # PUT(TDATE,YEAR2.)
FILEDATE = TDATE.strftime('%d%m%Y') # PUT(TDATE,DDMMYY8.)

#print(f"FILEDAY: {FILEDAY}")
#print(f"FILEMON: {FILEMON}")
#print(f"FILEYEAR: {FILEYEAR}")
#print(f"FILEDATE: {FILEDATE}")

# Second part: Validation check
if FILEDATE != REPTDATE:
    print(f"EPCU_CTCS IS NOT DATED {REPTDATE}")
    # Equivalent to ABORT 77 - exit with error code
    exit(77)
else:
    print("Date validation passed - files match")


#-----------------------------------------
# Step 3. Append 4 weeks data into CTCS_mm
#-----------------------------------------

def process_ctcs():
    try:
        print("DEBUG: Reading CTCS file...")
        # Read the file
        df_raw = pl.read_csv(
            ctcs_path,
            has_header=False,
            skip_rows=1,
            new_columns=["line"]
        )
        
        print(f"DEBUG: Read {df_raw.height} raw lines")
        
        # Filter out empty lines
        df_filtered = df_raw.filter(pl.col("line").str.len_chars() > 0)
        print(f"DEBUG: {df_filtered.height} lines after empty filter")
        
        # Add CHECK column and filter out 'TOTAL'
        df_with_check = df_filtered.with_columns([
            pl.col("line").str.slice(0, 5).alias("CHECK")
        ]).filter(pl.col("CHECK") != "TOTAL")
        
        print(f"DEBUG: {df_with_check.height} lines after TOTAL filter")
        
        if df_with_check.height == 0:
            print("No valid data found after filtering")
            return None
        
        # Process data - USING CORRECT POLARS STRING METHODS
        df_processed = df_with_check.with_columns([
            # TRANDT - using strptime with strict=False
            pl.col("line").str.slice(8, 8).str.strptime(pl.Date, "%Y%m%d", strict=False).alias("TRANDT"),
            
            # Numeric columns - using strip_chars() and strict=False
            pl.col("line").str.slice(17, 10).str.strip_chars().cast(pl.Int64, strict=False).alias("ACCTNO"),
            pl.col("line").str.slice(28, 5).str.strip_chars().cast(pl.Int64, strict=False).alias("NOTENO"),
            pl.col("line").str.slice(34, 6).str.strip_chars().cast(pl.Int64, strict=False).alias("CHEQNO"),
            pl.col("line").str.slice(41, 10).str.strip_chars().cast(pl.Float64, strict=False).alias("TRANAMT"),
            
            # String columns - using strip_chars() instead of strip()
            pl.col("line").str.slice(52, 2).str.strip_chars().alias("IND"),
            pl.col("line").str.slice(55, 1).str.strip_chars().alias("PRODIND"),
            pl.col("line").str.slice(57, 2).str.strip_chars().alias("TRANCD"),
            
            # REPTDATE
            pl.lit(int(RDATE)).alias("REPTDATE")
        ]).drop("CHECK")
        
        print(f"DEBUG: Successfully processed {df_processed.height} records")
        print(f"DEBUG: Columns: {df_processed.columns}")
        return df_processed
        
    except Exception as e:
        print(f"Error processing CTCS file: {e}")
        import traceback
        traceback.print_exc()
        return None


def append_macro():
    df_ctcs = process_ctcs()
    output_file = f"/pythonITD/mis_dev/output/parquet/CTCS_{REPTMON}.parquet"
    
    if REPTMON == "08":  # 1ST WEEK
        # Create new monthly file
        df_ctcs.write_parquet(output_file)
        print(f"Created new monthly file: {output_file}")
    else:
        if os.path.exists(output_file):
            # Read existing, remove duplicates, and append
            df_existing = pl.read_parquet(output_file)
            df_existing = df_existing.filter(pl.col("REPTDATE") != int(RDATE))
            df_combined = pl.concat([df_ctcs, df_existing])
            df_combined.write_parquet(output_file)
            print(f"Appended data to existing file: {output_file}")
        else:
            # File doesn't exist, create new one
            df_ctcs.write_parquet(output_file)
            print(f"Created new file (not 8th): {output_file}")

# Execute
append_macro()
